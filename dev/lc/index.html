<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lexical characteristics · Phonetics.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Phonetics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Phonetics.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../vowelplot/">Vowel plotting</a></li><li><a class="tocitem" href="../acd/">Acoustic distance</a></li><li class="is-active"><a class="tocitem" href>Lexical characteristics</a><ul class="internal"><li><a class="tocitem" href="#Phonological-neighborhood-density"><span>Phonological neighborhood density</span></a></li><li><a class="tocitem" href="#Phonotactic-probability"><span>Phonotactic probability</span></a></li><li><a class="tocitem" href="#Uniqueness-point"><span>Uniqueness point</span></a></li><li><a class="tocitem" href="#Function-documentation"><span>Function documentation</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../textvptree/">Text VP Tree</a></li><li><a class="tocitem" href="../phon_spectrogram/">Spectrograms</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Lexical characteristics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lexical characteristics</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/maetshju/Phonetics.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Lexical-characteristics"><a class="docs-heading-anchor" href="#Lexical-characteristics">Lexical characteristics</a><a id="Lexical-characteristics-1"></a><a class="docs-heading-anchor-permalink" href="#Lexical-characteristics" title="Permalink"></a></h1><p>There are some functions to calculate common lexical characteristics of words. These characteristics are a reflection of how a word relates to all the other words in a language, that is, how they relate to all other words in the lexicon.</p><h2 id="Phonological-neighborhood-density"><a class="docs-heading-anchor" href="#Phonological-neighborhood-density">Phonological neighborhood density</a><a id="Phonological-neighborhood-density-1"></a><a class="docs-heading-anchor-permalink" href="#Phonological-neighborhood-density" title="Permalink"></a></h2><p>Phonological neighborhood density, as described by Luce &amp; Pisoni (1998), as a concept is a set of words that sound similar to each other. Vitevitch &amp; Luce (2016) explain that it&#39;s common to operationalize this concept as the number of words that have a Levenshtein distance (minimal number of segment additions, subtractions, or substitutions to transform one word or string into another) of exactly 1 from the word in question.</p><p>The <code>pnd</code> function allows a user to calculate this value for a list of words based on a given corpus. The following example shows how to use the <code>pnd</code> function. Note that the entries in the sample corpus are given using the Arpabet transcription scheme.</p><pre><code class="language-julia hljs">using Phonetics
sample_corpus = [
[&quot;K&quot;, &quot;AE1&quot;, &quot;T&quot;], # cat
[&quot;K&quot;, &quot;AA1&quot;, &quot;B&quot;], # cob
[&quot;B&quot;, &quot;AE1&quot;, &quot;T&quot;], # bat
[&quot;T&quot;, &quot;AE1&quot;, &quot;T&quot;, &quot;S&quot;], # tats
[&quot;M&quot;, &quot;AA1&quot;, &quot;R&quot;, &quot;K&quot;], # mark
[&quot;K&quot;, &quot;AE1&quot;, &quot;B&quot;], # cab
]
pnd(sample_corpus, [[&quot;K&quot;, &quot;AE1&quot;, &quot;T&quot;]])</code></pre><div><div style = "float: left;"><span>1×2 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Query</th><th style = "text-align: left;">PND</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "Vector{String}" style = "text-align: left;">Array…</th><th title = "Int64" style = "text-align: left;">Int64</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">[&quot;K&quot;, &quot;AE1&quot;, &quot;T&quot;]</td><td style = "text-align: right;">2</td></tr></tbody></table></div><p>As we can see, [K AA1 T] <em>cat</em> has 2 phonological neighbors in the given corpus, so it has a phonological neighborhood density of 2. The data is returned in a <code>DataFrame</code> so that processing that uses tabular data can be performed.</p><p>A more likely scenario is calculating the phonological neighborhood density for each item in the CMU Pronouncing dictionary. For the purposes of this example, I&#39;ll assume you have already downloaded the <a href="http://www.speech.cs.cmu.edu/cgi-bin/cmudict">CMU Pronouncing Dictionary</a>. There is a bit of extra information at the top of the document that needs to be deleted, so make sure the first line in the document is the entry for &quot;!EXCLAMATION-POINT&quot;.</p><p>Now, the first thing we need to do is read the file into Julia and process it into a usable state. Because we&#39;re interested in the phonological transcriptions here, we&#39;ll strip away the orthographic representation.</p><pre><code class="language-julia hljs">using Phonetics
corpus = Vector()
open(&quot;cmudict-0.7b&quot;) do f
  lines = readlines(f)
  for line in lines
    phonological_transcription = split(split(line, &quot;  &quot;)[2])
    push!(corpus, phonological_transcription)
  end
end</code></pre><p>Notice that we called <code>split</code> twice. The <strong>first</strong> time was to split the orthographic representation from the phonological one, and they&#39;re separated by two spaces. We wanted the phonological transcription, so we took the second element from the <code>Array</code> that results from that call to <code>split</code>. The <strong>second</strong> call to <code>split</code> was to split the phonological representation into another <code>Array</code>. This is necessary because the CMU Pronouncing Dictionary uses a modified version of the Aprabet transcription scheme and doesn&#39;t always use only 1 character to represent a particular phoneme. So we can&#39;t just process each individual item in a string as we might be able to do for a 1 character to 1 phoneme mapping like the International Phonetic Alphabet. Representing each phoneme as one element in an <code>Array</code> allows us to process the data correctly.</p><p>Now that we have the corpus set up, all we need to do is call the <code>pnd</code> function.</p><pre><code class="language-julia hljs">neighborhood_density = pnd(corpus, corpus)</code></pre><p>The output from <code>pnd</code> is a <code>DataFrame</code> where the queries are in the first column and the associated neighborhood densities are in the second column. This <code>DataFrame</code> can then be used in subsequent statistical analyses or saved to a file for use in other programming language or software like R.</p><h3 id="Implementation-note"><a class="docs-heading-anchor" href="#Implementation-note">Implementation note</a><a id="Implementation-note-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-note" title="Permalink"></a></h3><p>The intuitive way of coding phonological neighborhood density involves comparing every item in the corpus against every other item in the corpus and counting how many neighbors each item has. However, this is computationally inefficient, as there are approximately <span>$n^2$</span> comparisons that must be performed. In this package, this process is sped up by using a spatial data structure called a <a href="https://en.wikipedia.org/wiki/Vantage-point_tree">vantage-point tree</a>. This data structure is a binarily branching tree where all the items on the left of a node are less than a particular distance away from the item in the node, and all those on the right are greater than or equal to that particular distance.</p><p>Because of the way that the data is organized in a vantage-point tree, fewer comparisons need to be made. While descending the tree, it can be determined whether any of the points in a branch from a particular node should be searched or not, limiting the number of branches that need to be traversed. In practical terms, this means that the Levenshtein distance is calculated fewer times for each item, and the phonological neighborhood density should be calculated faster for a data set than from using the traditional approach that compares each item to all the other ones in the corpus. At the time of writing this document, I am not aware of any phonological neighborhood density calculator/script that offers this kind of speedup.</p><h2 id="Phonotactic-probability"><a class="docs-heading-anchor" href="#Phonotactic-probability">Phonotactic probability</a><a id="Phonotactic-probability-1"></a><a class="docs-heading-anchor-permalink" href="#Phonotactic-probability" title="Permalink"></a></h2><p>The phonotactic probability is likelihood of observing a sequence in a given language. It&#39;s typically calculated as either the co-occurrence probability of a series of phones or diphones, or the cumulative transitional probability of moving from one portion of the sequence to the next.</p><p>This package currently provides the co-occurrence method of calculating the phonotactic probability, and this can be done taking the position of a phone or diphone into account, or just looking at the co-occurrence probability. By means of example:</p><pre><code class="language-julia hljs">sample_corpus = [
[&quot;K&quot;, &quot;AE1&quot;, &quot;T&quot;], # cat
[&quot;K&quot;, &quot;AA1&quot;, &quot;B&quot;], # cob
[&quot;B&quot;, &quot;AE1&quot;, &quot;T&quot;], # bat
[&quot;T&quot;, &quot;AE1&quot;, &quot;T&quot;, &quot;S&quot;], # tats
[&quot;M&quot;, &quot;AA1&quot;, &quot;R&quot;, &quot;K&quot;], # mark
[&quot;K&quot;, &quot;AE1&quot;, &quot;B&quot;], # cab
]
freq = [1,1,1,1,1,1]
p = prod([4,4,4] / 20)
phnprb(sample_corpus, freq, [[&quot;K&quot;, &quot;AE1&quot;, &quot;T&quot;]])</code></pre><div><div style = "float: left;"><span>1×2 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Query</th><th style = "text-align: left;">Probability</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "Vector{String}" style = "text-align: left;">Array…</th><th title = "Any" style = "text-align: left;">Any</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">[&quot;K&quot;, &quot;AE1&quot;, &quot;T&quot;]</td><td style = "text-align: left;">0.008</td></tr></tbody></table></div><p>In this example, each phone has 4 observations in the corpus, and the likelihood of observing each of those phones is 4/20. Because there are 3, the phonotactic probability of this sequence is <span>${\frac{4}{20}}^3$</span>, which is 0.008. Floating point errors sometimes occur in the arithmetic in programming, but this is unavoidable.</p><pre><code class="language-julia hljs">sample_corpus = [
[&quot;K&quot;, &quot;AE1&quot;, &quot;T&quot;], # cat
[&quot;K&quot;, &quot;AA1&quot;, &quot;B&quot;], # cob
[&quot;B&quot;, &quot;AE1&quot;, &quot;T&quot;], # bat
[&quot;T&quot;, &quot;AE1&quot;, &quot;T&quot;, &quot;S&quot;], # tats
[&quot;M&quot;, &quot;AA1&quot;, &quot;R&quot;, &quot;K&quot;], # mark
[&quot;K&quot;, &quot;AE1&quot;, &quot;B&quot;], # cab
]
freq = [1,1,1,1,1,1]
p = prod([3,2,3,2]/26)
phnprb(sample_corpus, freq, [[&quot;K&quot;, &quot;AE1&quot;, &quot;T&quot;]]; nchar=2)</code></pre><div><div style = "float: left;"><span>1×2 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Query</th><th style = "text-align: left;">Probability</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "Vector{String}" style = "text-align: left;">Array…</th><th title = "Any" style = "text-align: left;">Any</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">[&quot;K&quot;, &quot;AE1&quot;, &quot;T&quot;]</td><td style = "text-align: left;">7.87788e-5</td></tr></tbody></table></div><p>In this example here, the input is padded so that the beginning and ending of the word are taken into account when calculating the phonotactic probability. There are 3 counts of [. K] (where [.] is the word boundary symbol), 2 counts of [K AE1], 3 counts of [AE1 T], and 2 counts of [T .]. There are 26 total diphones observed in the corpus, so the phonotactic probability is calculated as</p><p class="math-container">\[\frac{3}{26} \times \frac{2}{26} \times \frac{3}{26} \times \frac{2}{26} \,.\]</p><h2 id="Uniqueness-point"><a class="docs-heading-anchor" href="#Uniqueness-point">Uniqueness point</a><a id="Uniqueness-point-1"></a><a class="docs-heading-anchor-permalink" href="#Uniqueness-point" title="Permalink"></a></h2><p>The uniqueness point of a word is defined as the segment in a sequence after which that sequence can be uniquely identified. In cohort models of speech perception, it is after this point that a listener will recognize a word while it&#39;s being spoken. As an example:</p><pre><code class="language-julia hljs">using Phonetics
sample_corpus = [
[&quot;K&quot;, &quot;AE1&quot;, &quot;T&quot;], # cat
[&quot;K&quot;, &quot;AA1&quot;, &quot;B&quot;], # cob
[&quot;B&quot;, &quot;AE1&quot;, &quot;T&quot;], # bat
[&quot;T&quot;, &quot;AE1&quot;, &quot;T&quot;, &quot;S&quot;], # tats
[&quot;M&quot;, &quot;AA1&quot;, &quot;R&quot;, &quot;K&quot;], # mark
[&quot;K&quot;, &quot;AE1&quot;, &quot;B&quot;], # cab
]
upt(sample_corpus, [[&quot;K&quot;, &quot;AA1&quot;, &quot;T&quot;]]; inCorpus=true)</code></pre><div><div style = "float: left;"><span>1×2 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Query</th><th style = "text-align: left;">UPT</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "Vector{String}" style = "text-align: left;">Array…</th><th title = "Any" style = "text-align: left;">Any</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">[&quot;K&quot;, &quot;AA1&quot;, &quot;T&quot;]</td><td style = "text-align: left;">2</td></tr></tbody></table></div><p>Here, [K AA1 B] <em>cob</em> has a uniqueness point of 2. Looking at the corpus, we can be sure we&#39;re looking at <em>cob</em> after observing the [AA1] because nothing else begins with the sequence [K AA1]. Thus, its uniqueness point is 2.</p><pre><code class="language-julia hljs">using Phonetics
sample_corpus = [
[&quot;K&quot;, &quot;AE1&quot;, &quot;T&quot;], # cat
[&quot;K&quot;, &quot;AA1&quot;, &quot;B&quot;], # cob
[&quot;B&quot;, &quot;AE1&quot;, &quot;T&quot;], # bat
[&quot;T&quot;, &quot;AE1&quot;, &quot;T&quot;, &quot;S&quot;], # tats
[&quot;M&quot;, &quot;AA1&quot;, &quot;R&quot;, &quot;K&quot;], # mark
[&quot;K&quot;, &quot;AE1&quot;, &quot;B&quot;], # cab
]
upt(sample_corpus, [[&quot;K&quot;, &quot;AE1&quot;, &quot;D&quot;]]; inCorpus=false)</code></pre><div><div style = "float: left;"><span>1×2 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Query</th><th style = "text-align: left;">UPT</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "Vector{String}" style = "text-align: left;">Array…</th><th title = "Any" style = "text-align: left;">Any</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">[&quot;K&quot;, &quot;AE1&quot;, &quot;D&quot;]</td><td style = "text-align: left;">3</td></tr></tbody></table></div><p>As is evident, given this sample corpus, [K AE1 D] <em>cad</em> is unique after the 3rd segment. That is, it can be uniquely identified after hearing the [D].</p><pre><code class="language-julia hljs">using Phonetics
sample_corpus = [
[&quot;K&quot;, &quot;AE1&quot;, &quot;T&quot;], # cat
[&quot;K&quot;, &quot;AA1&quot;, &quot;B&quot;], # cob
[&quot;B&quot;, &quot;AE1&quot;, &quot;T&quot;], # bat
[&quot;T&quot;, &quot;AE1&quot;, &quot;T&quot;, &quot;S&quot;], # tats
[&quot;M&quot;, &quot;AA1&quot;, &quot;R&quot;, &quot;K&quot;], # mark
[&quot;K&quot;, &quot;AE1&quot;, &quot;B&quot;], # cab
]
upt(sample_corpus, [[&quot;T&quot;, &quot;AE1&quot;, &quot;T&quot;]]; inCorpus=false)</code></pre><div><div style = "float: left;"><span>1×2 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">Query</th><th style = "text-align: left;">UPT</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "Vector{String}" style = "text-align: left;">Array…</th><th title = "Any" style = "text-align: left;">Any</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: left;">[&quot;T&quot;, &quot;AE1&quot;, &quot;T&quot;]</td><td style = "text-align: left;">4</td></tr></tbody></table></div><p>Here, [T AE1 T] <em>tat</em> cannot be uniquely identified until after the sequence is complete, so its uniqueness point is one longer than its length.</p><h2 id="Function-documentation"><a class="docs-heading-anchor" href="#Function-documentation">Function documentation</a><a id="Function-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Function-documentation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Phonetics.pnd-Tuple{Array, Array}" href="#Phonetics.pnd-Tuple{Array, Array}"><code>Phonetics.pnd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pnd(corpus::Array, queries::Array; [progress=true])</code></pre><p>Calculate the phonological neighborhood density (pnd) for each item in <code>queries</code> based on the items in <code>corpus</code>. This function uses a vantage point tree data structure to speed up the search for neighbors by pruning the search space. This function should work regardless of whether the items in <code>queries</code> are in <code>corpus</code> or not.</p><p><strong>Parameters</strong></p><ul><li><strong>corpus</strong> The corpus to be queried for phonological neighbors</li><li><strong>queries</strong> The items to query phonological neighbors for in <code>corpus</code></li><li><strong>progress</strong> Whether to display a progress meter or not</li></ul><p><strong>Returns</strong></p><ul><li>A <code>DataFrame</code> with the queries in the first column and the phonological   neighborhood density in the second</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maetshju/Phonetics.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Phonetics.phnprb-Tuple{Array, Array{Int64, N} where N, Array}" href="#Phonetics.phnprb-Tuple{Array, Array{Int64, N} where N, Array}"><code>Phonetics.phnprb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phnprb(corpus::Array, frequencies::Array, queries::Array; positional=false,
    nchar=1, pad=true)</code></pre><p>Calculates the phonotactic probability for each item in a list of queries based on a corpus</p><p><strong>Arguments</strong></p><ul><li><strong>corpus</strong> The corpus on which to base the probability calculations</li><li><strong>frequencies</strong> The frequencies associated with each element in <code>corpus</code></li><li><strong>queries</strong> The items for which the probability should be calculated</li></ul><p><strong>Keyword arguments</strong></p><ul><li><strong>positional</strong>  Whether to consider where in the query a given phone appears</li></ul><p>(e.g., should &quot;K&quot; as the first sound be considered a different category than &quot;K&quot;     as the second sound?)</p><ul><li><strong>nchar</strong> The number of characters for each n-gram that will be examined   (e.g., 2 for diphones)</li><li><strong>pad</strong> Whether to add padding to each query or not</li></ul><p><strong>Returns</strong></p><p>A <code>DataFrame</code> with the queries in the first column and the probability values     in the second</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maetshju/Phonetics.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Phonetics.upt-Tuple{Array, Array}" href="#Phonetics.upt-Tuple{Array, Array}"><code>Phonetics.upt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">upt(corpus, queries; [inCorpus=true])</code></pre><p>Calculates the phonological uniqueness point (upt) the items in <code>queries</code> based on the items in <code>corpus</code>. If the items are expected to be in the corpus, this function will calculate the uniqueness point to be when a branch can be considered to only represent 1 word. If the items are not expected to be in the corpus, the uniqueness point will be taken to be the depth at which the tree can no longer be traversed.</p><p><strong>Parameters</strong></p><ul><li><strong>corpus</strong> The items comprising the corpus to compare against when calculating   the uniqueness point of each query</li><li><strong>queries</strong> The items for which to calculate the uniqueness point</li><li><strong>inLexicon</strong> Whether the query items are expected to be in the corpus or not</li></ul><p><strong>Returns</strong></p><ul><li>A <code>DataFrame</code> with the queries in the first column and the uniqueness points   in the second</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maetshju/Phonetics.jl">source</a></section></article><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>Luce, P. A., &amp; Pisoni, D. B. (1998). Recognizing spoken words: The neighborhood activation model. <em>Ear and hearing, 19</em>(1), 1.</p><p>Vitevitch, M. S., &amp; Luce, P. A. (2016). Phonological neighborhood effects in spoken word perception and production. <em>Annual Review of Linguistics, 2</em>, 75-94.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../acd/">« Acoustic distance</a><a class="docs-footer-nextpage" href="../textvptree/">Text VP Tree »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Sunday 13 November 2022 04:52">Sunday 13 November 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
